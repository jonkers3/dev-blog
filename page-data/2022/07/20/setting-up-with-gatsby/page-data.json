{"componentChunkName":"component---src-pages-mdx-slug-js","path":"/2022/07/20/setting-up-with-gatsby/","result":{"data":{"mdx":{"frontmatter":{"title":"Setting Up a Dev Blog With Gatsby in 2022","date":"July 20, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Setting Up a Dev Blog With Gatsby in 2022\",\n  \"date\": \"2022-07-20T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Setting Up a Dev Blog with Gatsby in 2022\"), mdx(\"p\", null, \"Today we will set up our new dev blog. We will build it with Gatsby. The initial goals are basic functionality (an index page with links to individual posts) and a few other things one would probably like given the need to work with a lot of code - syntax highlighting being one good example, copy-to-clipboard button another.  We will use markdown files for our content.\"), mdx(\"p\", null, \"This is an example of how to bootstrap a new blog with Gatsby in 2022.\"), mdx(\"br\", null), mdx(\"h2\", null, \"1. Bootstrapping a new Gatsby Project\"), mdx(\"hr\", null), mdx(\"p\", null, \"We could install \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatbsy-cli\"), \" globally or we can run it with NPX, but either way, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"use the CLI to bootstrap the project\"), \".\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"cli\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"npx gatsby new\\n\")), mdx(\"p\", null, \"Run the CLI and follow the prompts.\"), mdx(\"p\", null, \"What kind of styling, what plugins, typescript or not, that sort of thing. We selected MDX support, responsive images, and React Helmet. For styling we're going to be use standard CSS modules. This generated the following gatsby-config.ts file for us:\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"gatsby-config.ts\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import type { GatsbyConfig } from 'gatsby'\\n\\nconst config: GatsbyConfig = {\\n  siteMetadata: {\\n    title: `My New Dev Blog`,\\n    siteUrl: `http://my.blog.local`\\n  },\\n\\n  graphqlTypegen: true,\\n\\n  plugins: [\\n    'gatsby-plugin-image',\\n    'gatsby-plugin-react-helmet',\\n    'gatsby-plugin-mdx',\\n    'gatsby-plugin-sharp',\\n    'gatsby-transformer-sharp',\\n\\n    {\\n      resolve: 'gatsby-source-filesystem',\\n      options: {\\n        name: 'images',\\n        path: './src/images/'\\n      },\\n      __key: 'images'\\n    },\\n\\n    {\\n      resolve: 'gatsby-source-filesystem',\\n      options: {\\n        name: 'pages',\\n        path: './src/pages/'\\n      },\\n      __key: 'pages'\\n    },\\n  ]\\n}\\n\\nexport default config\\n\")), mdx(\"p\", null, \"Set up an alias for our components directory so we can use absolute imports:\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"gatsby-node.js\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const path = require('path')\\nexports.onCreateWebpackConfig = ({ actions }) => {\\n  actions.setWebpackConfig({\\n    resolve: {\\n      alias: {\\n        '@components': path.resolve(__dirname, 'src', 'components')\\n      }\\n    }\\n  })\\n}\\n\")), mdx(\"p\", null, \"Typescript users will want to update their ts-config with the alias as well:\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"ts-config.json\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"compilerOptions\\\": {\\n    \\\"paths\\\": {\\n      \\\"@components/*\\\": [\\\"./src/components/*\\\"]\\n    },\\n    ...\\n\")), mdx(\"p\", null, \"If your setup is like mine, you're using Typescript with plain CSS modules for styling. If this is the case, you'll probably need a  definitions file along these lines to prevent the TS compiler from finding fault with our CSS module imports.\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/global.d.ts.ts\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"declare module '*.css' {\\n  const content: { [className: string]: string }\\n  export = content\\n}\\n\")), mdx(\"br\", null), mdx(\"h2\", null, \"2. Configuring a data source\"), mdx(\"hr\", null), mdx(\"p\", null, \"Make a folder called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog\"), \" in the project root. This is where we will keep the markdown files that comprise our collection of blog posts. We tell Gatsby about this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog\"), \" folder by adding one more item at the bottom of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"plugins\"), \" array in our gatsby-config, just below the other gatsby-source-filesystem definitions.\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"gatsby-config.ts\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"  plugins: [\\n    ...\\n\\n    {\\n      resolve: 'gatsby-source-filesystem',\\n      options: {\\n        name: 'blog',\\n        path: './blog/'\\n      },\\n      __key: 'blog'\\n    }\\n  ]\\n\")), mdx(\"p\", null, \"In effect, this folder is now visible to our GraphQL queries.\"), mdx(\"p\", null, \"As far as the posts themselves, as in the mdx files, we will organize them by date in subfolders. The mdx source behind this post is located in our filesystem at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog/2022/07/20/setting-up-with-gatsby/index.mdx\"), \", for example.\"), mdx(\"p\", null, \"Our file system will also determine the URL of our post, so the way we organize our files is extremely important. This folder structure that we want is basically this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\uD83D\\uDCE6blog\\n \\u2514 \\uD83D\\uDCC22022\\n \\u2502 \\u2514 \\uD83D\\uDCC207\\n \\u2502 \\u2502 \\u251C \\uD83D\\uDCC220\\n \\u2502 \\u2502 \\u2502 \\u2514 \\uD83D\\uDCC2setting-up-with-gatsby\\n \\u2502 \\u2502 \\u2502 \\u2502 \\u251C \\uD83D\\uDCDCindex.mdx\\n \\u2502 \\u2502 \\u2502 \\u2502 \\u2514 \\uD83D\\uDCDCmdx-graphql.png\\n \\u2502 \\u2502 \\u251C \\uD83D\\uDCC222\\n \\u2502 \\u2502 \\u2502 \\u2514 \\uD83D\\uDCC2setting-up-with-gatsby-ii\\n \\u2502 \\u2502 \\u2502 \\u2502 \\u251C \\uD83D\\uDCDCgithub-pages-settings.png\\n \\u2502 \\u2502 \\u2502 \\u2502 \\u2514 \\uD83D\\uDCDCindex.mdx\\n\")), mdx(\"br\", null), mdx(\"h2\", null, \"3. Create the blog index page\"), mdx(\"hr\", null), mdx(\"p\", null, \"Start the development server...\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"npm start\\n\")), mdx(\"p\", null, \"At \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://localhost:8000/___graphql\"\n  }, \"localhost:8000/___graphql\"), \", you get the GraphQL query interface. Basically this is just a nice UI to query Gatsby's data layer, meaning the things you have configured Gatsby to be able to get data from (like our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog\"), \" folder). We use the UI to develop the queries we need to power our site.\"), mdx(\"p\", null, \"Try running the following query while our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog\"), \" folder is still empty:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"query BlogPosts {\\n  allMdx(sort: {order: DESC, fields: [frontmatter___date]}, limit: 1000) {\\n    edges {\\n      node {\\n        slug\\n        frontmatter {\\n          date(formatString: \\\"DD MMMM YYYY\\\")\\n          title\\n        }\\n        wordCount {\\n          words\\n        }\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"GraphQL will throws an error: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Value \\\"frontmatter___date\\\" does not exist in \\\"MdxFieldsEnum\\\" enum\"), \". We can fix this by placing at least \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://raw.githubusercontent.com/jonkers3/dev-blog/master/blog/2022/07/20/setting-up-with-gatsby/index.mdx\"\n  }, \"one MDX file\"), \" that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"does\"), \" have a date field in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog\"), \" folder.\"), mdx(\"p\", null, \"But what \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"exactly\"), \" is going on here_?\"), mdx(\"p\", null, \"If we really wanted to, we could add the following code to our gatsby-node file, and the query would return an empty result set instead of erroring.\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"gatsby-node.ts\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes } = actions\\n\\n  createTypes(`\\n    type Mdx implements Node {\\n      frontmatter: MdxFrontmatter\\n    }\\n    type MdxFrontmatter {\\n      date: Date @dateformat\\n    }\\n  `)\\n}\\n\\nBut we don't plan on having an empty blog or markdown files with inconsistent metadata, so it isn't really necessary. It helps illuminate a bit how GraphQL queries work with frontmatter in Gatsby.\\n\\nTo create our index page, replace the contents of `src/pages/index.js` file with the following:\\n\\n#### *`src/pages/index.js`*\\n```jsx\\nimport * as React from 'react'\\nimport { graphql, Link } from 'gatsby'\\n\\nconst Blog = ({ data }) => {\\n  return (\\n    <>\\n      {data.allMdx.nodes.map((node) => (\\n        <article key={node.id}>\\n          <h2>\\n            <Link to={`/${node.slug}`}>\\n              {node.frontmatter.title}\\n            </Link>\\n          </h2>\\n          <p>{node.frontmatter.date}</p>\\n          <p>{node.slug}</p>\\n        </article>\\n      ))}\\n    </>\\n  )\\n}\\n\\nexport const query = graphql`\\n  query {\\n    allMdx(sort: { fields: frontmatter___date, order: DESC }) {\\n      nodes {\\n        frontmatter {\\n          date(formatString: \\\"MMMM D, YYYY\\\")\\n          title\\n        }\\n        slug\\n        id\\n      }\\n    }\\n  }\\n`\\n\\nexport default Blog\\n\")), mdx(\"p\", null, \"Gatsby works some magic here, and the results of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"query\"), \" that we export end up getting passed right back into the component as a prop called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \".\"), mdx(\"br\", null), mdx(\"h2\", null, \"4. Create a Template for Blog Posts\"), mdx(\"hr\", null), mdx(\"p\", null, \"There should now be a list of posts at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://localhost:8000\"\n  }, \"localhost:8000\"), \". Now that we have an index page, we probably want to be able to see individual posts as well. We just need a file to serve as our blog template:\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/pages/{mdx.slug}.js\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import * as React from 'react'\\nimport { graphql } from 'gatsby'\\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\\n\\nconst BlogPost = ({ data }) => {\\n  return (\\n    <>\\n      <p>{data.mdx.frontmatter.date}</p>\\n      <MDXRenderer>{data.mdx.body}</MDXRenderer>\\n    </>\\n  )\\n}\\n\\nexport const query = graphql`\\n  query ($id: String) {\\n    mdx(id: { eq: $id }) {\\n      frontmatter {\\n        title\\n        date(formatString: \\\"MMMM D, YYYY\\\")\\n      }\\n      body\\n    }\\n  }\\n`\\n\\nexport default BlogPost\\n\")), mdx(\"p\", null, \"Now, we should be able to click the links on the index page and be brought to a page with the full content of the post.\"), mdx(\"br\", null), mdx(\"h2\", null, \"5. Create a Layout\"), mdx(\"hr\", null), mdx(\"p\", null, \"The main thing we are in need of is some kind of navigation control. Eventually we need a header, footer, and that sort of thing. Getting our content nicely centered would also be nice.\"), mdx(\"p\", null, \"We will create a shared Layout component to address these things.\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/components/Layout/index.jsx\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from 'react'\\nimport * as styles from './layout.module.css'\\n\\nconst Layout = ({ children }) => (\\n  <div className={styles.pageContainer}>\\n      <nav>\\n        <ul className={styles.navLinks}>\\n          <li className>\\n            <Link to='/'>Home</Link>\\n          </li>\\n        </ul>\\n      </nav>\\n    <div className={styles.innerContainer}>{children}</div>\\n  </div>\\n)\\n\\nexport default Layout\\n\")), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/components/Layout/layout.module.css\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \".page-container {\\n  margin: 0 auto;\\n  padding: 0;\\n  box-sizing: border-box;\\n  max-width: 860px;\\n  font-family: sans-serif;\\n}\\n\\n.inner-container {\\n  margin-top: 7em;\\n  padding: 12px;\\n}\\n\\n.nav-links {\\n  column-count: 2;\\n  column-gap: 85%;\\n  display: flex;\\n  list-style: none;\\n  padding-left: 0;\\n}\\n\")), mdx(\"p\", null, \"Speaking of styles, let's also make a global CSS file for rules that need to apply everywhere.\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/styles/global.css\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \"body {\\n  margin: 0px;\\n  font-family: 'Open Sans', sans-serif;\\n  line-height: 1.65;\\n  text-rendering: optimizeLegibility;\\n  font-size: 1.015rem;\\n}\\n\")), mdx(\"p\", null, \"That needs to be referenced by a gatsby-browser file, so create one:\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"gatsby-browser.js\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \"import './src/styles/global.css'\\n\")), mdx(\"p\", null, \"Wrap our two pages so that they are using our new layout component.\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/pages/{mdx.slug}.js\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"+ import Layout from '@components/Layout'\\n\\nconst BlogPost = ({ data }) => {\\n  return (\\n-   <>\\n+   <Layout>\\n      <p>{data.mdx.frontmatter.date}</p>\\n      <MDXRenderer>{data.mdx.body}</MDXRenderer>\\n+   </Layout>\\n-   </>\\n  )\\n}\\n\")), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/pages/index.js\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"+ import Layout from '@components/Layout'\\n\\nconst Blog = ({ data }) => {\\n  return (\\n-   <>\\n+   <Layout>\\n      {data.allMdx.nodes.map((node) => (\\n        <article key={node.id}>\\n        ....\\n      ))}\\n+   </Layout>\\n-   </>\\n  )\\n}\\n\")), mdx(\"br\", null), mdx(\"h2\", null, \"6. Configure MDX to work with Inline Images\"), mdx(\"hr\", null), mdx(\"p\", null, \"Storing image files directly alongside the markdown file seems perfect for pictures that are only used in one place, screenshots for a page like this being a pretty good example. In other words, we want a structure like this for our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog\"), \" folder:\"), mdx(\"p\", null, \"We want to be able to reference images in our Markdown files like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-markdown\"\n  }, \"![alt text](hello.png)\\n\")), mdx(\"p\", null, \"For this to work, we need to make a change to the configuration for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-plugin-mdx\"), \" plugin.\"), mdx(\"p\", null, \"Replace the existing reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'gatsby-plugin-mdx'\"), \" with a new object definition, like this:\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"gatsby-config.ts\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"filename='gatsby-config.ts'\",\n    \"filename\": \"'gatsby-config.ts'\"\n  }, \"- 'gatsby-plugin-mdx',\\n\\n+ {\\n+   resolve: `gatsby-plugin-mdx`,\\n+   options: {\\n+     gatsbyRemarkPlugins: [\\n+       {\\n+         resolve: `gatsby-remark-images`,\\n+       }\\n+     ]\\n+   }\\n+ },\\n\")), mdx(\"p\", null, \"Now, upon restarting the development server, can reference images from within our markdown files like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-markdown\"\n  }, \"\")), mdx(\"p\", null, \"As a bonus, we also get a neat progressive loading effect, as well as responsive thumbnails.\"), mdx(\"br\", null), mdx(\"h2\", null, \"7. Color Syntax Highlighting with Prism.js\"), mdx(\"hr\", null), mdx(\"p\", null, \"Our use case involves the frequent usage of code blocks, so we might as well make them as easy to digest and as visually pleasing as possible. Prism.js gives us syntax highlighting in almost any language with fairly minimal effort. To get the basic functionality we need only do three things:\"), mdx(\"h3\", null, \"Install prism-react-renderer (and mdx-utils)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"npm i prism-react-renderer mdx-utils\\n\")), mdx(\"h3\", null, \"Create a new component to render code blocks\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/components/Code/index.jsx\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from 'react'\\nimport Highlight, { defaultProps } from 'prism-react-renderer'\\nimport theme from 'prism-react-renderer/themes/github'\\nimport * as styles from './code.module.css'\\n\\nconst Code = ({ codeString, language, ...props }) => {\\n  return (\\n    <Highlight\\n      {...defaultProps}\\n      code={codeString}\\n      language={language}\\n      theme={theme}\\n    >\\n      {({ className, style, tokens, getLineProps, getTokenProps }) => (\\n        <pre\\n          className={className}\\n          style={{ ...style, padding: '20px', position: 'relative' }}\\n        >\\n\\n          {tokens.map((line, i) => (\\n            <div key={i} {...getLineProps({ line, key: i })}>\\n              {line.map((token, key) => (\\n                <span key={key} {...getTokenProps({ token, key })} />\\n              ))}\\n            </div>\\n          ))}\\n        </pre>\\n      )}\\n    </Highlight>\\n  )\\n}\\n\\nexport default Code\\n\")), mdx(\"h3\", null, \"Use MDXProvider wrap MDXRenderer\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/pages/{mdx.slug}.js\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import * as React from 'react'\\nimport { graphql } from 'gatsby'\\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\\nimport { MDXProvider } from '@mdx-js/react'\\nimport { preToCodeBlock } from 'mdx-utils'\\nimport Code from '@components/Code'\\nimport Layout from '@components/Layout'\\n\\nconst components = {\\n  pre: (preProps) => {\\n    const props = preToCodeBlock(preProps)\\n\\n    if (props) {\\n      return <Code {...props} />\\n    } else {\\n      return <pre {...preProps} />\\n    }\\n  }\\n}\\n\\nconst BlogPost = ({ data }) => {\\n  return (\\n    <Layout>\\n      <MDXProvider components={components}>\\n        <p>{data.mdx.frontmatter.date}</p>\\n        <MDXRenderer>{data.mdx.body}</MDXRenderer>\\n      </MDXProvider>\\n    </Layout>\\n  )\\n}\\n\\nexport const query = graphql`\\n  query ($id: String) {\\n    mdx(id: { eq: $id }) {\\n      frontmatter {\\n        title\\n        date(formatString: \\\"MMMM D, YYYY\\\")\\n      }\\n      body\\n    }\\n  }\\n`\\n\\nexport default BlogPost\\n\")), mdx(\"p\", null, \"That's basically it. This looks pretty nice once it is working, but since presenting code is a fundamental part of a dev blog, we're going to want to improve some things. Line numbers, for example, are something we will want to add.\"), mdx(\"p\", null, \"Given the endless possibilities we will have to have a post entirely dedicated to prism.js and advanced options for it. For now, we'll just be happy about how nice and colorful things already are.\"), mdx(\"br\", null), mdx(\"h2\", null, \"8. Copy to Clipboard Button\"), mdx(\"hr\", null), mdx(\"p\", null, \"If you've made it to this point, you should have a pretty spiffy looking setup coming together. As far as our initial list of desired features, the only thing we have yet to do is the Copy-to-Clipboard button. This is the last task of our initial setup. We need to change only one file to get this working. Add the following code to it:\"), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/components/Code/index.jsx\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from 'react'\\nimport Highlight, { defaultProps } from 'prism-react-renderer'\\nimport theme from 'prism-react-renderer/themes/github'\\nimport * as styles from './code.module.css'\\n\\n+ const CopyButton = (props) => <button className={styles.button} {...props} />\\n\\nconst Code = ({ codeString, language, ...props }) => {\\n  const [isCopied, setIsCopied] = React.useState(false)\\n\\n  return (\\n    <Highlight\\n      {...defaultProps}\\n      code={codeString}\\n      language={language}\\n      theme={theme}\\n    >\\n      {({ className, style, tokens, getLineProps, getTokenProps }) => (\\n        <pre\\n          className={className}\\n          style={{ ...style, padding: '20px', position: 'relative' }}\\n        >\\n+         <CopyButton\\n+           onClick={() => {\\n+             navigator.clipboard.writeText(codeString)\\n+             setIsCopied(true)\\n+             setTimeout(() => setIsCopied(false), 4000)\\n+           }}\\n+         >\\n+           {isCopied ? <i>Copied!</i> : 'Copy'}\\n+         </CopyButton>\\n\\n          {tokens.map((line, i) => (\\n            <div key={i} {...getLineProps({ line, key: i })}>\\n              {line.map((token, key) => (\\n                <span key={key} {...getTokenProps({ token, key })} />\\n              ))}\\n            </div>\\n          ))}\\n        </pre>\\n      )}\\n    </Highlight>\\n  )\\n}\\n\\nexport default Code\\n\")), mdx(\"h4\", null, mdx(\"em\", {\n    parentName: \"h4\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"src/components/Code/code.module.css\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \".button {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  margin: 8px;\\n  padding: 8px 12px 8px 12px;\\n  border-radius: 8px;\\n  border-width: 0;\\n  background: deepskyblue;\\n}\\n\\n\")), mdx(\"p\", null, \"I mostly just like the way having the button looks, to be honest. It isn't super useful in every possible situation, but it is still kind of nice to have there.\"), mdx(\"br\", null), mdx(\"h2\", null, \"9. Wrapup\"), mdx(\"hr\", null), mdx(\"p\", null, \"We now drop markdown and image files into our blog folder and know that when our app gets built and deployed, our files will be processed into blazing fast pre-built static pages, looking good and ready to be served.\"), mdx(\"p\", null, \"Markdown and React go \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"good\"), \" together. Gatsby's data layer is a perfect use case for GraphQL. These things are really meant for each other, and it is not surprising that this stack is a popular way to build websites.\"), mdx(\"p\", null, \"For the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/dev-blog/2022/07/22/setting-up-with-gatsby-ii\"\n  }, \"second part of this post\"), \", we will concern ourselves with how it is that our app is going to be built and deployed. Then we will do it.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"471b413f-a5d8-5bad-82de-2a06ba546687","slug":"2022/07/20/setting-up-with-gatsby/","__params":{"slug":"2022"}}},"staticQueryHashes":[]}